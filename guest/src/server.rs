// Generated by `wit-bindgen` 0.3.0. DO NOT EDIT!

#[allow(clippy::all)]
pub mod types{ use super::wit_bindgen;
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Vec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
  }
  impl core::fmt::Debug for Vec4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Vec4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
  }
  impl core::fmt::Debug for Vec3 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Vec3").field("x", &self.x).field("y", &self.y).field("z", &self.z).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Vec2 {
    pub x: f32,
    pub y: f32,
  }
  impl core::fmt::Debug for Vec2 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Vec2").field("x", &self.x).field("y", &self.y).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Quat {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
  }
  impl core::fmt::Debug for Quat {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Quat").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct Mat4 {
    pub x: Vec4,
    pub y: Vec4,
    pub z: Vec4,
    pub w: Vec4,
  }
  impl core::fmt::Debug for Mat4 {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("Mat4").field("x", &self.x).field("y", &self.y).field("z", &self.z).field("w", &self.w).finish()
    }
  }
  #[repr(C)]
  #[derive(Copy, Clone)]
  pub struct EntityId {
    pub id0: u64,
    pub id1: u64,
  }
  impl core::fmt::Debug for EntityId {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      f.debug_struct("EntityId").field("id0", &self.id0).field("id1", &self.id1).finish()
    }
  }
  
}


#[allow(clippy::all)]
pub mod component{ use super::wit_bindgen;
  pub type EntityId = super::types::EntityId;
  pub type Mat4 = super::types::Mat4;
  pub type Quat = super::types::Quat;
  pub type Vec2 = super::types::Vec2;
  pub type Vec3 = super::types::Vec3;
  pub type Vec4 = super::types::Vec4;
  #[derive(Clone)]
  pub enum ComponentOptionTypeResult{
    TypeEmpty(Option<()>),
    TypeBool(Option<bool>),
    TypeEntityId(Option<EntityId>),
    TypeF32(Option<f32>),
    TypeF64(Option<f64>),
    TypeMat4(Option<Mat4>),
    TypeI32(Option<i32>),
    TypeQuat(Option<Quat>),
    TypeString(Option<wit_bindgen::rt::string::String>),
    TypeU32(Option<u32>),
    TypeU64(Option<u64>),
    TypeVec2(Option<Vec2>),
    TypeVec3(Option<Vec3>),
    TypeVec4(Option<Vec4>),
  }
  impl core::fmt::Debug for ComponentOptionTypeResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentOptionTypeResult::TypeEmpty(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeEmpty").field(e).finish()
        }
        ComponentOptionTypeResult::TypeBool(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeBool").field(e).finish()
        }
        ComponentOptionTypeResult::TypeEntityId(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeEntityId").field(e).finish()
        }
        ComponentOptionTypeResult::TypeF32(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeF32").field(e).finish()
        }
        ComponentOptionTypeResult::TypeF64(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeF64").field(e).finish()
        }
        ComponentOptionTypeResult::TypeMat4(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeMat4").field(e).finish()
        }
        ComponentOptionTypeResult::TypeI32(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeI32").field(e).finish()
        }
        ComponentOptionTypeResult::TypeQuat(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeQuat").field(e).finish()
        }
        ComponentOptionTypeResult::TypeString(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeString").field(e).finish()
        }
        ComponentOptionTypeResult::TypeU32(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeU32").field(e).finish()
        }
        ComponentOptionTypeResult::TypeU64(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeU64").field(e).finish()
        }
        ComponentOptionTypeResult::TypeVec2(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeVec2").field(e).finish()
        }
        ComponentOptionTypeResult::TypeVec3(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeVec3").field(e).finish()
        }
        ComponentOptionTypeResult::TypeVec4(e) => {
          f.debug_tuple("ComponentOptionTypeResult::TypeVec4").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentOptionTypeParam<'a,>{
    TypeEmpty(Option<()>),
    TypeBool(Option<bool>),
    TypeEntityId(Option<EntityId>),
    TypeF32(Option<f32>),
    TypeF64(Option<f64>),
    TypeMat4(Option<Mat4>),
    TypeI32(Option<i32>),
    TypeQuat(Option<Quat>),
    TypeString(Option<&'a str>),
    TypeU32(Option<u32>),
    TypeU64(Option<u64>),
    TypeVec2(Option<Vec2>),
    TypeVec3(Option<Vec3>),
    TypeVec4(Option<Vec4>),
  }
  impl<'a,> core::fmt::Debug for ComponentOptionTypeParam<'a,> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentOptionTypeParam::TypeEmpty(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeEmpty").field(e).finish()
        }
        ComponentOptionTypeParam::TypeBool(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeBool").field(e).finish()
        }
        ComponentOptionTypeParam::TypeEntityId(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeEntityId").field(e).finish()
        }
        ComponentOptionTypeParam::TypeF32(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeF32").field(e).finish()
        }
        ComponentOptionTypeParam::TypeF64(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeF64").field(e).finish()
        }
        ComponentOptionTypeParam::TypeMat4(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeMat4").field(e).finish()
        }
        ComponentOptionTypeParam::TypeI32(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeI32").field(e).finish()
        }
        ComponentOptionTypeParam::TypeQuat(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeQuat").field(e).finish()
        }
        ComponentOptionTypeParam::TypeString(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeString").field(e).finish()
        }
        ComponentOptionTypeParam::TypeU32(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeU32").field(e).finish()
        }
        ComponentOptionTypeParam::TypeU64(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeU64").field(e).finish()
        }
        ComponentOptionTypeParam::TypeVec2(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeVec2").field(e).finish()
        }
        ComponentOptionTypeParam::TypeVec3(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeVec3").field(e).finish()
        }
        ComponentOptionTypeParam::TypeVec4(e) => {
          f.debug_tuple("ComponentOptionTypeParam::TypeVec4").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentListTypeResult{
    TypeEmpty(wit_bindgen::rt::vec::Vec::<()>),
    TypeBool(wit_bindgen::rt::vec::Vec::<bool>),
    TypeEntityId(wit_bindgen::rt::vec::Vec::<EntityId>),
    TypeF32(wit_bindgen::rt::vec::Vec::<f32>),
    TypeF64(wit_bindgen::rt::vec::Vec::<f64>),
    TypeMat4(wit_bindgen::rt::vec::Vec::<Mat4>),
    TypeI32(wit_bindgen::rt::vec::Vec::<i32>),
    TypeQuat(wit_bindgen::rt::vec::Vec::<Quat>),
    TypeString(wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>),
    TypeU32(wit_bindgen::rt::vec::Vec::<u32>),
    TypeU64(wit_bindgen::rt::vec::Vec::<u64>),
    TypeVec2(wit_bindgen::rt::vec::Vec::<Vec2>),
    TypeVec3(wit_bindgen::rt::vec::Vec::<Vec3>),
    TypeVec4(wit_bindgen::rt::vec::Vec::<Vec4>),
  }
  impl core::fmt::Debug for ComponentListTypeResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentListTypeResult::TypeEmpty(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeEmpty").field(e).finish()
        }
        ComponentListTypeResult::TypeBool(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeBool").field(e).finish()
        }
        ComponentListTypeResult::TypeEntityId(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeEntityId").field(e).finish()
        }
        ComponentListTypeResult::TypeF32(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeF32").field(e).finish()
        }
        ComponentListTypeResult::TypeF64(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeF64").field(e).finish()
        }
        ComponentListTypeResult::TypeMat4(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeMat4").field(e).finish()
        }
        ComponentListTypeResult::TypeI32(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeI32").field(e).finish()
        }
        ComponentListTypeResult::TypeQuat(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeQuat").field(e).finish()
        }
        ComponentListTypeResult::TypeString(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeString").field(e).finish()
        }
        ComponentListTypeResult::TypeU32(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeU32").field(e).finish()
        }
        ComponentListTypeResult::TypeU64(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeU64").field(e).finish()
        }
        ComponentListTypeResult::TypeVec2(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeVec2").field(e).finish()
        }
        ComponentListTypeResult::TypeVec3(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeVec3").field(e).finish()
        }
        ComponentListTypeResult::TypeVec4(e) => {
          f.debug_tuple("ComponentListTypeResult::TypeVec4").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentListTypeParam<'a,>{
    TypeEmpty(&'a [()]),
    TypeBool(&'a [bool]),
    TypeEntityId(&'a [EntityId]),
    TypeF32(&'a [f32]),
    TypeF64(&'a [f64]),
    TypeMat4(&'a [Mat4]),
    TypeI32(&'a [i32]),
    TypeQuat(&'a [Quat]),
    TypeString(&'a [&'a str]),
    TypeU32(&'a [u32]),
    TypeU64(&'a [u64]),
    TypeVec2(&'a [Vec2]),
    TypeVec3(&'a [Vec3]),
    TypeVec4(&'a [Vec4]),
  }
  impl<'a,> core::fmt::Debug for ComponentListTypeParam<'a,> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentListTypeParam::TypeEmpty(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeEmpty").field(e).finish()
        }
        ComponentListTypeParam::TypeBool(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeBool").field(e).finish()
        }
        ComponentListTypeParam::TypeEntityId(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeEntityId").field(e).finish()
        }
        ComponentListTypeParam::TypeF32(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeF32").field(e).finish()
        }
        ComponentListTypeParam::TypeF64(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeF64").field(e).finish()
        }
        ComponentListTypeParam::TypeMat4(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeMat4").field(e).finish()
        }
        ComponentListTypeParam::TypeI32(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeI32").field(e).finish()
        }
        ComponentListTypeParam::TypeQuat(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeQuat").field(e).finish()
        }
        ComponentListTypeParam::TypeString(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeString").field(e).finish()
        }
        ComponentListTypeParam::TypeU32(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeU32").field(e).finish()
        }
        ComponentListTypeParam::TypeU64(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeU64").field(e).finish()
        }
        ComponentListTypeParam::TypeVec2(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeVec2").field(e).finish()
        }
        ComponentListTypeParam::TypeVec3(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeVec3").field(e).finish()
        }
        ComponentListTypeParam::TypeVec4(e) => {
          f.debug_tuple("ComponentListTypeParam::TypeVec4").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentTypeResult{
    TypeEmpty(()),
    TypeBool(bool),
    TypeEntityId(EntityId),
    TypeF32(f32),
    TypeF64(f64),
    TypeMat4(Mat4),
    TypeI32(i32),
    TypeQuat(Quat),
    TypeString(wit_bindgen::rt::string::String),
    TypeU32(u32),
    TypeU64(u64),
    TypeVec2(Vec2),
    TypeVec3(Vec3),
    TypeVec4(Vec4),
    TypeList(ComponentListTypeResult),
    TypeOption(ComponentOptionTypeResult),
  }
  impl core::fmt::Debug for ComponentTypeResult {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentTypeResult::TypeEmpty(e) => {
          f.debug_tuple("ComponentTypeResult::TypeEmpty").field(e).finish()
        }
        ComponentTypeResult::TypeBool(e) => {
          f.debug_tuple("ComponentTypeResult::TypeBool").field(e).finish()
        }
        ComponentTypeResult::TypeEntityId(e) => {
          f.debug_tuple("ComponentTypeResult::TypeEntityId").field(e).finish()
        }
        ComponentTypeResult::TypeF32(e) => {
          f.debug_tuple("ComponentTypeResult::TypeF32").field(e).finish()
        }
        ComponentTypeResult::TypeF64(e) => {
          f.debug_tuple("ComponentTypeResult::TypeF64").field(e).finish()
        }
        ComponentTypeResult::TypeMat4(e) => {
          f.debug_tuple("ComponentTypeResult::TypeMat4").field(e).finish()
        }
        ComponentTypeResult::TypeI32(e) => {
          f.debug_tuple("ComponentTypeResult::TypeI32").field(e).finish()
        }
        ComponentTypeResult::TypeQuat(e) => {
          f.debug_tuple("ComponentTypeResult::TypeQuat").field(e).finish()
        }
        ComponentTypeResult::TypeString(e) => {
          f.debug_tuple("ComponentTypeResult::TypeString").field(e).finish()
        }
        ComponentTypeResult::TypeU32(e) => {
          f.debug_tuple("ComponentTypeResult::TypeU32").field(e).finish()
        }
        ComponentTypeResult::TypeU64(e) => {
          f.debug_tuple("ComponentTypeResult::TypeU64").field(e).finish()
        }
        ComponentTypeResult::TypeVec2(e) => {
          f.debug_tuple("ComponentTypeResult::TypeVec2").field(e).finish()
        }
        ComponentTypeResult::TypeVec3(e) => {
          f.debug_tuple("ComponentTypeResult::TypeVec3").field(e).finish()
        }
        ComponentTypeResult::TypeVec4(e) => {
          f.debug_tuple("ComponentTypeResult::TypeVec4").field(e).finish()
        }
        ComponentTypeResult::TypeList(e) => {
          f.debug_tuple("ComponentTypeResult::TypeList").field(e).finish()
        }
        ComponentTypeResult::TypeOption(e) => {
          f.debug_tuple("ComponentTypeResult::TypeOption").field(e).finish()
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum ComponentTypeParam<'a,>{
    TypeEmpty(()),
    TypeBool(bool),
    TypeEntityId(EntityId),
    TypeF32(f32),
    TypeF64(f64),
    TypeMat4(Mat4),
    TypeI32(i32),
    TypeQuat(Quat),
    TypeString(&'a str),
    TypeU32(u32),
    TypeU64(u64),
    TypeVec2(Vec2),
    TypeVec3(Vec3),
    TypeVec4(Vec4),
    TypeList(ComponentListTypeParam<'a,>),
    TypeOption(ComponentOptionTypeParam<'a,>),
  }
  impl<'a,> core::fmt::Debug for ComponentTypeParam<'a,> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
      match self {
        ComponentTypeParam::TypeEmpty(e) => {
          f.debug_tuple("ComponentTypeParam::TypeEmpty").field(e).finish()
        }
        ComponentTypeParam::TypeBool(e) => {
          f.debug_tuple("ComponentTypeParam::TypeBool").field(e).finish()
        }
        ComponentTypeParam::TypeEntityId(e) => {
          f.debug_tuple("ComponentTypeParam::TypeEntityId").field(e).finish()
        }
        ComponentTypeParam::TypeF32(e) => {
          f.debug_tuple("ComponentTypeParam::TypeF32").field(e).finish()
        }
        ComponentTypeParam::TypeF64(e) => {
          f.debug_tuple("ComponentTypeParam::TypeF64").field(e).finish()
        }
        ComponentTypeParam::TypeMat4(e) => {
          f.debug_tuple("ComponentTypeParam::TypeMat4").field(e).finish()
        }
        ComponentTypeParam::TypeI32(e) => {
          f.debug_tuple("ComponentTypeParam::TypeI32").field(e).finish()
        }
        ComponentTypeParam::TypeQuat(e) => {
          f.debug_tuple("ComponentTypeParam::TypeQuat").field(e).finish()
        }
        ComponentTypeParam::TypeString(e) => {
          f.debug_tuple("ComponentTypeParam::TypeString").field(e).finish()
        }
        ComponentTypeParam::TypeU32(e) => {
          f.debug_tuple("ComponentTypeParam::TypeU32").field(e).finish()
        }
        ComponentTypeParam::TypeU64(e) => {
          f.debug_tuple("ComponentTypeParam::TypeU64").field(e).finish()
        }
        ComponentTypeParam::TypeVec2(e) => {
          f.debug_tuple("ComponentTypeParam::TypeVec2").field(e).finish()
        }
        ComponentTypeParam::TypeVec3(e) => {
          f.debug_tuple("ComponentTypeParam::TypeVec3").field(e).finish()
        }
        ComponentTypeParam::TypeVec4(e) => {
          f.debug_tuple("ComponentTypeParam::TypeVec4").field(e).finish()
        }
        ComponentTypeParam::TypeList(e) => {
          f.debug_tuple("ComponentTypeParam::TypeList").field(e).finish()
        }
        ComponentTypeParam::TypeOption(e) => {
          f.debug_tuple("ComponentTypeParam::TypeOption").field(e).finish()
        }
      }
    }
  }
  pub type Entity<'a,> = &'a [(u32,ComponentTypeParam<'a,>,)];
  #[allow(clippy::all)]
  pub fn get_component(entity: EntityId,index: u32,) -> Option<ComponentTypeResult>{
    
    #[allow(unused_imports)]
    use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
    unsafe {
      
      #[repr(align(8))]
      struct RetArea([u8; 88]);
      let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
      let super::types::EntityId{ id0:id00, id1:id10, } = entity;
      let ptr1 = ret_area.as_mut_ptr() as i32;
      #[link(wasm_import_module = "component")]
      extern "C" {
        #[cfg_attr(target_arch = "wasm32", link_name = "get-component")]
        #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_get-component")]
        fn wit_import(
        _: i64, _: i64, _: i32, _: i32, );
      }
      wit_import(wit_bindgen::rt::as_i64(id00), wit_bindgen::rt::as_i64(id10), wit_bindgen::rt::as_i32(index), ptr1);
      match i32::from(*((ptr1 + 0) as *const u8)) {
        0 => None,
        1 => Some({{match i32::from(*((ptr1 + 8) as *const u8)) {
          0 => ComponentTypeResult::TypeEmpty(()),
          1 => ComponentTypeResult::TypeBool({
            #[cfg(not(debug_assertions))]
            { core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 16) as *const u8)) as u8) }
            #[cfg(debug_assertions)]
            {
              match i32::from(*((ptr1 + 16) as *const u8)) {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
              }
            }
          }),
          2 => ComponentTypeResult::TypeEntityId(super::types::EntityId{id0:*((ptr1 + 16) as *const i64) as u64, id1:*((ptr1 + 24) as *const i64) as u64, }),
          3 => ComponentTypeResult::TypeF32(*((ptr1 + 16) as *const f32)),
          4 => ComponentTypeResult::TypeF64(*((ptr1 + 16) as *const f64)),
          5 => ComponentTypeResult::TypeMat4(super::types::Mat4{x:super::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }, y:super::types::Vec4{x:*((ptr1 + 32) as *const f32), y:*((ptr1 + 36) as *const f32), z:*((ptr1 + 40) as *const f32), w:*((ptr1 + 44) as *const f32), }, z:super::types::Vec4{x:*((ptr1 + 48) as *const f32), y:*((ptr1 + 52) as *const f32), z:*((ptr1 + 56) as *const f32), w:*((ptr1 + 60) as *const f32), }, w:super::types::Vec4{x:*((ptr1 + 64) as *const f32), y:*((ptr1 + 68) as *const f32), z:*((ptr1 + 72) as *const f32), w:*((ptr1 + 76) as *const f32), }, }),
          6 => ComponentTypeResult::TypeI32(*((ptr1 + 16) as *const i32)),
          7 => ComponentTypeResult::TypeQuat(super::types::Quat{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
          8 => ComponentTypeResult::TypeString({
            let len2 = *((ptr1 + 20) as *const i32) as usize;
            
            {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 16) as *const i32) as *mut _, len2, len2)).unwrap()}}
          }),
          9 => ComponentTypeResult::TypeU32(*((ptr1 + 16) as *const i32) as u32),
          10 => ComponentTypeResult::TypeU64(*((ptr1 + 16) as *const i64) as u64),
          11 => ComponentTypeResult::TypeVec2(super::types::Vec2{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), }),
          12 => ComponentTypeResult::TypeVec3(super::types::Vec3{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), }),
          13 => ComponentTypeResult::TypeVec4(super::types::Vec4{x:*((ptr1 + 16) as *const f32), y:*((ptr1 + 20) as *const f32), z:*((ptr1 + 24) as *const f32), w:*((ptr1 + 28) as *const f32), }),
          14 => ComponentTypeResult::TypeList({{match i32::from(*((ptr1 + 16) as *const u8)) {
            0 => ComponentListTypeResult::TypeEmpty({
              let len3 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len3, len3)
            }),
            1 => ComponentListTypeResult::TypeBool({
              let base4 = *((ptr1 + 20) as *const i32);
              let len4 = *((ptr1 + 24) as *const i32);
              let mut result4 = Vec::with_capacity(len4 as usize);
              for i in 0..len4 {
                let base = base4 + i *1;
                result4.push({
                  #[cfg(not(debug_assertions))]
                  { core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                  #[cfg(debug_assertions)]
                  {
                    match i32::from(*((base + 0) as *const u8)) {
                      0 => false,
                      1 => true,
                      _ => panic!("invalid bool discriminant"),
                    }
                  }
                });
              }
              wit_bindgen::rt::dealloc(base4, (len4 as usize) * 1, 1);
              
              result4
            }),
            2 => ComponentListTypeResult::TypeEntityId({
              let len5 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len5, len5)
            }),
            3 => ComponentListTypeResult::TypeF32({
              let len6 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len6, len6)
            }),
            4 => ComponentListTypeResult::TypeF64({
              let len7 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len7, len7)
            }),
            5 => ComponentListTypeResult::TypeMat4({
              let len8 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len8, len8)
            }),
            6 => ComponentListTypeResult::TypeI32({
              let len9 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len9, len9)
            }),
            7 => ComponentListTypeResult::TypeQuat({
              let len10 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len10, len10)
            }),
            8 => ComponentListTypeResult::TypeString({
              let base12 = *((ptr1 + 20) as *const i32);
              let len12 = *((ptr1 + 24) as *const i32);
              let mut result12 = Vec::with_capacity(len12 as usize);
              for i in 0..len12 {
                let base = base12 + i *8;
                result12.push({
                  let len11 = *((base + 4) as *const i32) as usize;
                  
                  {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len11, len11)).unwrap()}}
                });
              }
              wit_bindgen::rt::dealloc(base12, (len12 as usize) * 8, 4);
              
              result12
            }),
            9 => ComponentListTypeResult::TypeU32({
              let len13 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len13, len13)
            }),
            10 => ComponentListTypeResult::TypeU64({
              let len14 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len14, len14)
            }),
            11 => ComponentListTypeResult::TypeVec2({
              let len15 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len15, len15)
            }),
            12 => ComponentListTypeResult::TypeVec3({
              let len16 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len16, len16)
            }),
            #[cfg(debug_assertions)]13 => ComponentListTypeResult::TypeVec4({
              let len17 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len17, len17)
            }),
            #[cfg(not(debug_assertions))]_ => ComponentListTypeResult::TypeVec4({
              let len17 = *((ptr1 + 24) as *const i32) as usize;
              
              Vec::from_raw_parts(*((ptr1 + 20) as *const i32) as *mut _, len17, len17)
            }),
            #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
          }}}),
          #[cfg(debug_assertions)]15 => ComponentTypeResult::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
            0 => ComponentOptionTypeResult::TypeEmpty(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(()),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            1 => ComponentOptionTypeResult::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some({
                #[cfg(not(debug_assertions))]
                { core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                #[cfg(debug_assertions)]
                {
                  match i32::from(*((ptr1 + 25) as *const u8)) {
                    0 => false,
                    1 => true,
                    _ => panic!("invalid bool discriminant"),
                  }
                }
              }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            2 => ComponentOptionTypeResult::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            3 => ComponentOptionTypeResult::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const f32)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            4 => ComponentOptionTypeResult::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 32) as *const f64)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            5 => ComponentOptionTypeResult::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            6 => ComponentOptionTypeResult::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const i32)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            7 => ComponentOptionTypeResult::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            8 => ComponentOptionTypeResult::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some({
                let len18 = *((ptr1 + 32) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len18, len18))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len18, len18)).unwrap()}}
              }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            9 => ComponentOptionTypeResult::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const i32) as u32),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            10 => ComponentOptionTypeResult::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 32) as *const i64) as u64),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            11 => ComponentOptionTypeResult::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            12 => ComponentOptionTypeResult::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(debug_assertions)]13 => ComponentOptionTypeResult::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(not(debug_assertions))]_ => ComponentOptionTypeResult::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
          }}}),
          #[cfg(not(debug_assertions))]_ => ComponentTypeResult::TypeOption({{match i32::from(*((ptr1 + 16) as *const u8)) {
            0 => ComponentOptionTypeResult::TypeEmpty(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(()),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            1 => ComponentOptionTypeResult::TypeBool(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some({
                #[cfg(not(debug_assertions))]
                { core::mem::transmute::<u8, bool>(i32::from(*((ptr1 + 25) as *const u8)) as u8) }
                #[cfg(debug_assertions)]
                {
                  match i32::from(*((ptr1 + 25) as *const u8)) {
                    0 => false,
                    1 => true,
                    _ => panic!("invalid bool discriminant"),
                  }
                }
              }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            2 => ComponentOptionTypeResult::TypeEntityId(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::EntityId{id0:*((ptr1 + 32) as *const i64) as u64, id1:*((ptr1 + 40) as *const i64) as u64, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            3 => ComponentOptionTypeResult::TypeF32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const f32)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            4 => ComponentOptionTypeResult::TypeF64(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 32) as *const f64)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            5 => ComponentOptionTypeResult::TypeMat4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }, y:super::types::Vec4{x:*((ptr1 + 44) as *const f32), y:*((ptr1 + 48) as *const f32), z:*((ptr1 + 52) as *const f32), w:*((ptr1 + 56) as *const f32), }, z:super::types::Vec4{x:*((ptr1 + 60) as *const f32), y:*((ptr1 + 64) as *const f32), z:*((ptr1 + 68) as *const f32), w:*((ptr1 + 72) as *const f32), }, w:super::types::Vec4{x:*((ptr1 + 76) as *const f32), y:*((ptr1 + 80) as *const f32), z:*((ptr1 + 84) as *const f32), w:*((ptr1 + 88) as *const f32), }, }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            6 => ComponentOptionTypeResult::TypeI32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const i32)),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            7 => ComponentOptionTypeResult::TypeQuat(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Quat{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            8 => ComponentOptionTypeResult::TypeString(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some({
                let len18 = *((ptr1 + 32) as *const i32) as usize;
                
                {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len18, len18))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((ptr1 + 28) as *const i32) as *mut _, len18, len18)).unwrap()}}
              }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            9 => ComponentOptionTypeResult::TypeU32(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 28) as *const i32) as u32),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            10 => ComponentOptionTypeResult::TypeU64(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(*((ptr1 + 32) as *const i64) as u64),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            11 => ComponentOptionTypeResult::TypeVec2(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec2{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            12 => ComponentOptionTypeResult::TypeVec3(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec3{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(debug_assertions)]13 => ComponentOptionTypeResult::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(not(debug_assertions))]_ => ComponentOptionTypeResult::TypeVec4(match i32::from(*((ptr1 + 24) as *const u8)) {
              0 => None,
              1 => Some(super::types::Vec4{x:*((ptr1 + 28) as *const f32), y:*((ptr1 + 32) as *const f32), z:*((ptr1 + 36) as *const f32), w:*((ptr1 + 40) as *const f32), }),
              #[cfg(not(debug_assertions))]
              _ => core::hint::unreachable_unchecked(),
              #[cfg(debug_assertions)]
              _ => panic!("invalid enum discriminant"),
            }),
            #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
          }}}),
          #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
        }}}),
        #[cfg(not(debug_assertions))]
        _ => core::hint::unreachable_unchecked(),
        #[cfg(debug_assertions)]
        _ => panic!("invalid enum discriminant"),
      }
    }
  }
  #[allow(clippy::all)]
  pub fn add_component(entity: EntityId,index: u32,value: ComponentTypeParam<'_,>,){
    
    #[allow(unused_imports)]
    use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
    unsafe {
      let mut cleanup_list = Vec::new();
      
      #[repr(align(8))]
      struct RetArea([u8; 104]);
      let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
      let ptr0 = ret_area.as_mut_ptr() as i32;let super::types::EntityId{ id0:id01, id1:id11, } = entity;
      *((ptr0 + 0) as *mut i64) = wit_bindgen::rt::as_i64(id01);
      *((ptr0 + 8) as *mut i64) = wit_bindgen::rt::as_i64(id11);
      *((ptr0 + 16) as *mut i32) = wit_bindgen::rt::as_i32(index);
      match value {
        ComponentTypeParam::TypeEmpty(e) => {
          *((ptr0 + 24) as *mut u8) = (0i32) as u8;
          let () = e;
          
        },
        ComponentTypeParam::TypeBool(e) => {
          *((ptr0 + 24) as *mut u8) = (1i32) as u8;
          *((ptr0 + 32) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
          
        },
        ComponentTypeParam::TypeEntityId(e) => {
          *((ptr0 + 24) as *mut u8) = (2i32) as u8;
          let super::types::EntityId{ id0:id03, id1:id13, } = e;
          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(id03);
          *((ptr0 + 40) as *mut i64) = wit_bindgen::rt::as_i64(id13);
          
        },
        ComponentTypeParam::TypeF32(e) => {
          *((ptr0 + 24) as *mut u8) = (3i32) as u8;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(e);
          
        },
        ComponentTypeParam::TypeF64(e) => {
          *((ptr0 + 24) as *mut u8) = (4i32) as u8;
          *((ptr0 + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
          
        },
        ComponentTypeParam::TypeMat4(e) => {
          *((ptr0 + 24) as *mut u8) = (5i32) as u8;
          let super::types::Mat4{ x:x4, y:y4, z:z4, w:w4, } = e;
          let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = x4;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
          let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = y4;
          *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
          *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
          *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
          *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
          let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = z4;
          *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
          *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
          *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
          *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
          let super::types::Vec4{ x:x8, y:y8, z:z8, w:w8, } = w4;
          *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(x8);
          *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(y8);
          *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(z8);
          *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(w8);
          
        },
        ComponentTypeParam::TypeI32(e) => {
          *((ptr0 + 24) as *mut u8) = (6i32) as u8;
          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
          
        },
        ComponentTypeParam::TypeQuat(e) => {
          *((ptr0 + 24) as *mut u8) = (7i32) as u8;
          let super::types::Quat{ x:x9, y:y9, z:z9, w:w9, } = e;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x9);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y9);
          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z9);
          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w9);
          
        },
        ComponentTypeParam::TypeString(e) => {
          *((ptr0 + 24) as *mut u8) = (8i32) as u8;
          let vec10 = e;
          let ptr10 = vec10.as_ptr() as i32;
          let len10 = vec10.len() as i32;
          *((ptr0 + 36) as *mut i32) = len10;
          *((ptr0 + 32) as *mut i32) = ptr10;
          
        },
        ComponentTypeParam::TypeU32(e) => {
          *((ptr0 + 24) as *mut u8) = (9i32) as u8;
          *((ptr0 + 32) as *mut i32) = wit_bindgen::rt::as_i32(e);
          
        },
        ComponentTypeParam::TypeU64(e) => {
          *((ptr0 + 24) as *mut u8) = (10i32) as u8;
          *((ptr0 + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
          
        },
        ComponentTypeParam::TypeVec2(e) => {
          *((ptr0 + 24) as *mut u8) = (11i32) as u8;
          let super::types::Vec2{ x:x11, y:y11, } = e;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x11);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y11);
          
        },
        ComponentTypeParam::TypeVec3(e) => {
          *((ptr0 + 24) as *mut u8) = (12i32) as u8;
          let super::types::Vec3{ x:x12, y:y12, z:z12, } = e;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x12);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y12);
          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z12);
          
        },
        ComponentTypeParam::TypeVec4(e) => {
          *((ptr0 + 24) as *mut u8) = (13i32) as u8;
          let super::types::Vec4{ x:x13, y:y13, z:z13, w:w13, } = e;
          *((ptr0 + 32) as *mut f32) = wit_bindgen::rt::as_f32(x13);
          *((ptr0 + 36) as *mut f32) = wit_bindgen::rt::as_f32(y13);
          *((ptr0 + 40) as *mut f32) = wit_bindgen::rt::as_f32(z13);
          *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(w13);
          
        },
        ComponentTypeParam::TypeList(e) => {
          *((ptr0 + 24) as *mut u8) = (14i32) as u8;
          match e {
            ComponentListTypeParam::TypeEmpty(e) => {
              *((ptr0 + 32) as *mut u8) = (0i32) as u8;
              let vec14 = e;
              let ptr14 = vec14.as_ptr() as i32;
              let len14 = vec14.len() as i32;
              *((ptr0 + 40) as *mut i32) = len14;
              *((ptr0 + 36) as *mut i32) = ptr14;
              
            },
            ComponentListTypeParam::TypeBool(e) => {
              *((ptr0 + 32) as *mut u8) = (1i32) as u8;
              let vec15 = e;
              let len15 = vec15.len() as i32;
              let layout15 = alloc::Layout::from_size_align_unchecked(vec15.len() * 1, 1);
              let result15 = if layout15.size() != 0
              {
                let ptr = alloc::alloc(layout15);
                if ptr.is_null()
                {
                  alloc::handle_alloc_error(layout15);
                }
                ptr
              }else {
                core::ptr::null_mut()
              };
              for (i, e) in vec15.into_iter().enumerate() {
                let base = result15 as i32 + (i as i32) * 1;
                {
                  *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                  
                }}
                *((ptr0 + 40) as *mut i32) = len15;
                *((ptr0 + 36) as *mut i32) = result15 as i32;
                cleanup_list.extend_from_slice(&[(result15, layout15),]);
                
              },
              ComponentListTypeParam::TypeEntityId(e) => {
                *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                let vec16 = e;
                let ptr16 = vec16.as_ptr() as i32;
                let len16 = vec16.len() as i32;
                *((ptr0 + 40) as *mut i32) = len16;
                *((ptr0 + 36) as *mut i32) = ptr16;
                
              },
              ComponentListTypeParam::TypeF32(e) => {
                *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                let vec17 = e;
                let ptr17 = vec17.as_ptr() as i32;
                let len17 = vec17.len() as i32;
                *((ptr0 + 40) as *mut i32) = len17;
                *((ptr0 + 36) as *mut i32) = ptr17;
                
              },
              ComponentListTypeParam::TypeF64(e) => {
                *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                let vec18 = e;
                let ptr18 = vec18.as_ptr() as i32;
                let len18 = vec18.len() as i32;
                *((ptr0 + 40) as *mut i32) = len18;
                *((ptr0 + 36) as *mut i32) = ptr18;
                
              },
              ComponentListTypeParam::TypeMat4(e) => {
                *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                let vec19 = e;
                let ptr19 = vec19.as_ptr() as i32;
                let len19 = vec19.len() as i32;
                *((ptr0 + 40) as *mut i32) = len19;
                *((ptr0 + 36) as *mut i32) = ptr19;
                
              },
              ComponentListTypeParam::TypeI32(e) => {
                *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                let vec20 = e;
                let ptr20 = vec20.as_ptr() as i32;
                let len20 = vec20.len() as i32;
                *((ptr0 + 40) as *mut i32) = len20;
                *((ptr0 + 36) as *mut i32) = ptr20;
                
              },
              ComponentListTypeParam::TypeQuat(e) => {
                *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                let vec21 = e;
                let ptr21 = vec21.as_ptr() as i32;
                let len21 = vec21.len() as i32;
                *((ptr0 + 40) as *mut i32) = len21;
                *((ptr0 + 36) as *mut i32) = ptr21;
                
              },
              ComponentListTypeParam::TypeString(e) => {
                *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                let vec23 = e;
                let len23 = vec23.len() as i32;
                let layout23 = alloc::Layout::from_size_align_unchecked(vec23.len() * 8, 4);
                let result23 = if layout23.size() != 0
                {
                  let ptr = alloc::alloc(layout23);
                  if ptr.is_null()
                  {
                    alloc::handle_alloc_error(layout23);
                  }
                  ptr
                }else {
                  core::ptr::null_mut()
                };
                for (i, e) in vec23.into_iter().enumerate() {
                  let base = result23 as i32 + (i as i32) * 8;
                  {
                    let vec22 = e;
                    let ptr22 = vec22.as_ptr() as i32;
                    let len22 = vec22.len() as i32;
                    *((base + 4) as *mut i32) = len22;
                    *((base + 0) as *mut i32) = ptr22;
                    
                  }}
                  *((ptr0 + 40) as *mut i32) = len23;
                  *((ptr0 + 36) as *mut i32) = result23 as i32;
                  cleanup_list.extend_from_slice(&[(result23, layout23),]);
                  
                },
                ComponentListTypeParam::TypeU32(e) => {
                  *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                  let vec24 = e;
                  let ptr24 = vec24.as_ptr() as i32;
                  let len24 = vec24.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len24;
                  *((ptr0 + 36) as *mut i32) = ptr24;
                  
                },
                ComponentListTypeParam::TypeU64(e) => {
                  *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                  let vec25 = e;
                  let ptr25 = vec25.as_ptr() as i32;
                  let len25 = vec25.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len25;
                  *((ptr0 + 36) as *mut i32) = ptr25;
                  
                },
                ComponentListTypeParam::TypeVec2(e) => {
                  *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                  let vec26 = e;
                  let ptr26 = vec26.as_ptr() as i32;
                  let len26 = vec26.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len26;
                  *((ptr0 + 36) as *mut i32) = ptr26;
                  
                },
                ComponentListTypeParam::TypeVec3(e) => {
                  *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                  let vec27 = e;
                  let ptr27 = vec27.as_ptr() as i32;
                  let len27 = vec27.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len27;
                  *((ptr0 + 36) as *mut i32) = ptr27;
                  
                },
                ComponentListTypeParam::TypeVec4(e) => {
                  *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                  let vec28 = e;
                  let ptr28 = vec28.as_ptr() as i32;
                  let len28 = vec28.len() as i32;
                  *((ptr0 + 40) as *mut i32) = len28;
                  *((ptr0 + 36) as *mut i32) = ptr28;
                  
                },
              };
              
            },
            ComponentTypeParam::TypeOption(e) => {
              *((ptr0 + 24) as *mut u8) = (15i32) as u8;
              match e {
                ComponentOptionTypeParam::TypeEmpty(e) => {
                  *((ptr0 + 32) as *mut u8) = (0i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let () = e;
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeBool(e) => {
                  *((ptr0 + 32) as *mut u8) = (1i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 41) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeEntityId(e) => {
                  *((ptr0 + 32) as *mut u8) = (2i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::EntityId{ id0:id030, id1:id130, } = e;
                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(id030);
                      *((ptr0 + 56) as *mut i64) = wit_bindgen::rt::as_i64(id130);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeF32(e) => {
                  *((ptr0 + 32) as *mut u8) = (3i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeF64(e) => {
                  *((ptr0 + 32) as *mut u8) = (4i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 48) as *mut f64) = wit_bindgen::rt::as_f64(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeMat4(e) => {
                  *((ptr0 + 32) as *mut u8) = (5i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Mat4{ x:x31, y:y31, z:z31, w:w31, } = e;
                      let super::types::Vec4{ x:x32, y:y32, z:z32, w:w32, } = x31;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x32);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y32);
                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z32);
                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w32);
                      let super::types::Vec4{ x:x33, y:y33, z:z33, w:w33, } = y31;
                      *((ptr0 + 60) as *mut f32) = wit_bindgen::rt::as_f32(x33);
                      *((ptr0 + 64) as *mut f32) = wit_bindgen::rt::as_f32(y33);
                      *((ptr0 + 68) as *mut f32) = wit_bindgen::rt::as_f32(z33);
                      *((ptr0 + 72) as *mut f32) = wit_bindgen::rt::as_f32(w33);
                      let super::types::Vec4{ x:x34, y:y34, z:z34, w:w34, } = z31;
                      *((ptr0 + 76) as *mut f32) = wit_bindgen::rt::as_f32(x34);
                      *((ptr0 + 80) as *mut f32) = wit_bindgen::rt::as_f32(y34);
                      *((ptr0 + 84) as *mut f32) = wit_bindgen::rt::as_f32(z34);
                      *((ptr0 + 88) as *mut f32) = wit_bindgen::rt::as_f32(w34);
                      let super::types::Vec4{ x:x35, y:y35, z:z35, w:w35, } = w31;
                      *((ptr0 + 92) as *mut f32) = wit_bindgen::rt::as_f32(x35);
                      *((ptr0 + 96) as *mut f32) = wit_bindgen::rt::as_f32(y35);
                      *((ptr0 + 100) as *mut f32) = wit_bindgen::rt::as_f32(z35);
                      *((ptr0 + 104) as *mut f32) = wit_bindgen::rt::as_f32(w35);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeI32(e) => {
                  *((ptr0 + 32) as *mut u8) = (6i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeQuat(e) => {
                  *((ptr0 + 32) as *mut u8) = (7i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Quat{ x:x36, y:y36, z:z36, w:w36, } = e;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x36);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y36);
                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z36);
                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w36);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeString(e) => {
                  *((ptr0 + 32) as *mut u8) = (8i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let vec37 = e;
                      let ptr37 = vec37.as_ptr() as i32;
                      let len37 = vec37.len() as i32;
                      *((ptr0 + 48) as *mut i32) = len37;
                      *((ptr0 + 44) as *mut i32) = ptr37;
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeU32(e) => {
                  *((ptr0 + 32) as *mut u8) = (9i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 44) as *mut i32) = wit_bindgen::rt::as_i32(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeU64(e) => {
                  *((ptr0 + 32) as *mut u8) = (10i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      *((ptr0 + 48) as *mut i64) = wit_bindgen::rt::as_i64(e);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeVec2(e) => {
                  *((ptr0 + 32) as *mut u8) = (11i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Vec2{ x:x38, y:y38, } = e;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x38);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y38);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeVec3(e) => {
                  *((ptr0 + 32) as *mut u8) = (12i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Vec3{ x:x39, y:y39, z:z39, } = e;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x39);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y39);
                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z39);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
                ComponentOptionTypeParam::TypeVec4(e) => {
                  *((ptr0 + 32) as *mut u8) = (13i32) as u8;
                  match e {
                    Some(e) => {
                      *((ptr0 + 40) as *mut u8) = (1i32) as u8;
                      let super::types::Vec4{ x:x40, y:y40, z:z40, w:w40, } = e;
                      *((ptr0 + 44) as *mut f32) = wit_bindgen::rt::as_f32(x40);
                      *((ptr0 + 48) as *mut f32) = wit_bindgen::rt::as_f32(y40);
                      *((ptr0 + 52) as *mut f32) = wit_bindgen::rt::as_f32(z40);
                      *((ptr0 + 56) as *mut f32) = wit_bindgen::rt::as_f32(w40);
                      
                    },
                    None => {
                      {
                        *((ptr0 + 40) as *mut u8) = (0i32) as u8;
                        
                      }
                    },
                  };
                },
              };
              
            },
          };
          
          #[link(wasm_import_module = "component")]
          extern "C" {
            #[cfg_attr(target_arch = "wasm32", link_name = "add-component")]
            #[cfg_attr(not(target_arch = "wasm32"), link_name = "component_add-component")]
            fn wit_import(
            _: i32, );
          }
          wit_import(ptr0);
          for (ptr, layout) in cleanup_list {
            
            if layout.size() != 0 {
              
              alloc::dealloc(ptr, layout);
              
            }
            
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod entity{ use super::wit_bindgen;
      pub type EntityData<'a,> = super::component::Entity<'a,>;
      pub type EntityId = super::types::EntityId;
      #[allow(clippy::all)]
      pub fn spawn(data: EntityData<'_,>,) -> EntityId{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{{alloc, vec::Vec, string::String}};
        unsafe {
          let mut cleanup_list = Vec::new();
          
          #[repr(align(8))]
          struct RetArea([u8; 16]);
          let mut ret_area = core::mem::MaybeUninit::<RetArea>::uninit();
          let vec40 = data;
          let len40 = vec40.len() as i32;
          let layout40 = alloc::Layout::from_size_align_unchecked(vec40.len() * 88, 8);
          let result40 = if layout40.size() != 0
          {
            let ptr = alloc::alloc(layout40);
            if ptr.is_null()
            {
              alloc::handle_alloc_error(layout40);
            }
            ptr
          }else {
            core::ptr::null_mut()
          };
          for (i, e) in vec40.into_iter().enumerate() {
            let base = result40 as i32 + (i as i32) * 88;
            {
              let (t0_0, t0_1, ) = e;
              *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(t0_0);
              match t0_1 {
                super::component::ComponentTypeParam::TypeEmpty(e) => {
                  *((base + 8) as *mut u8) = (0i32) as u8;
                  let () = e;
                  
                },
                super::component::ComponentTypeParam::TypeBool(e) => {
                  *((base + 8) as *mut u8) = (1i32) as u8;
                  *((base + 16) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                  
                },
                super::component::ComponentTypeParam::TypeEntityId(e) => {
                  *((base + 8) as *mut u8) = (2i32) as u8;
                  let super::types::EntityId{ id0:id02, id1:id12, } = e;
                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(id02);
                  *((base + 24) as *mut i64) = wit_bindgen::rt::as_i64(id12);
                  
                },
                super::component::ComponentTypeParam::TypeF32(e) => {
                  *((base + 8) as *mut u8) = (3i32) as u8;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(e);
                  
                },
                super::component::ComponentTypeParam::TypeF64(e) => {
                  *((base + 8) as *mut u8) = (4i32) as u8;
                  *((base + 16) as *mut f64) = wit_bindgen::rt::as_f64(e);
                  
                },
                super::component::ComponentTypeParam::TypeMat4(e) => {
                  *((base + 8) as *mut u8) = (5i32) as u8;
                  let super::types::Mat4{ x:x3, y:y3, z:z3, w:w3, } = e;
                  let super::types::Vec4{ x:x4, y:y4, z:z4, w:w4, } = x3;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x4);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y4);
                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z4);
                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w4);
                  let super::types::Vec4{ x:x5, y:y5, z:z5, w:w5, } = y3;
                  *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(x5);
                  *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(y5);
                  *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(z5);
                  *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(w5);
                  let super::types::Vec4{ x:x6, y:y6, z:z6, w:w6, } = z3;
                  *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(x6);
                  *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(y6);
                  *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(z6);
                  *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(w6);
                  let super::types::Vec4{ x:x7, y:y7, z:z7, w:w7, } = w3;
                  *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(x7);
                  *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(y7);
                  *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(z7);
                  *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(w7);
                  
                },
                super::component::ComponentTypeParam::TypeI32(e) => {
                  *((base + 8) as *mut u8) = (6i32) as u8;
                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                  
                },
                super::component::ComponentTypeParam::TypeQuat(e) => {
                  *((base + 8) as *mut u8) = (7i32) as u8;
                  let super::types::Quat{ x:x8, y:y8, z:z8, w:w8, } = e;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x8);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y8);
                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z8);
                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w8);
                  
                },
                super::component::ComponentTypeParam::TypeString(e) => {
                  *((base + 8) as *mut u8) = (8i32) as u8;
                  let vec9 = e;
                  let ptr9 = vec9.as_ptr() as i32;
                  let len9 = vec9.len() as i32;
                  *((base + 20) as *mut i32) = len9;
                  *((base + 16) as *mut i32) = ptr9;
                  
                },
                super::component::ComponentTypeParam::TypeU32(e) => {
                  *((base + 8) as *mut u8) = (9i32) as u8;
                  *((base + 16) as *mut i32) = wit_bindgen::rt::as_i32(e);
                  
                },
                super::component::ComponentTypeParam::TypeU64(e) => {
                  *((base + 8) as *mut u8) = (10i32) as u8;
                  *((base + 16) as *mut i64) = wit_bindgen::rt::as_i64(e);
                  
                },
                super::component::ComponentTypeParam::TypeVec2(e) => {
                  *((base + 8) as *mut u8) = (11i32) as u8;
                  let super::types::Vec2{ x:x10, y:y10, } = e;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x10);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y10);
                  
                },
                super::component::ComponentTypeParam::TypeVec3(e) => {
                  *((base + 8) as *mut u8) = (12i32) as u8;
                  let super::types::Vec3{ x:x11, y:y11, z:z11, } = e;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x11);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y11);
                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z11);
                  
                },
                super::component::ComponentTypeParam::TypeVec4(e) => {
                  *((base + 8) as *mut u8) = (13i32) as u8;
                  let super::types::Vec4{ x:x12, y:y12, z:z12, w:w12, } = e;
                  *((base + 16) as *mut f32) = wit_bindgen::rt::as_f32(x12);
                  *((base + 20) as *mut f32) = wit_bindgen::rt::as_f32(y12);
                  *((base + 24) as *mut f32) = wit_bindgen::rt::as_f32(z12);
                  *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(w12);
                  
                },
                super::component::ComponentTypeParam::TypeList(e) => {
                  *((base + 8) as *mut u8) = (14i32) as u8;
                  match e {
                    super::component::ComponentListTypeParam::TypeEmpty(e) => {
                      *((base + 16) as *mut u8) = (0i32) as u8;
                      let vec13 = e;
                      let ptr13 = vec13.as_ptr() as i32;
                      let len13 = vec13.len() as i32;
                      *((base + 24) as *mut i32) = len13;
                      *((base + 20) as *mut i32) = ptr13;
                      
                    },
                    super::component::ComponentListTypeParam::TypeBool(e) => {
                      *((base + 16) as *mut u8) = (1i32) as u8;
                      let vec14 = e;
                      let len14 = vec14.len() as i32;
                      let layout14 = alloc::Layout::from_size_align_unchecked(vec14.len() * 1, 1);
                      let result14 = if layout14.size() != 0
                      {
                        let ptr = alloc::alloc(layout14);
                        if ptr.is_null()
                        {
                          alloc::handle_alloc_error(layout14);
                        }
                        ptr
                      }else {
                        core::ptr::null_mut()
                      };
                      for (i, e) in vec14.into_iter().enumerate() {
                        let base = result14 as i32 + (i as i32) * 1;
                        {
                          *((base + 0) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                          
                        }}
                        *((base + 24) as *mut i32) = len14;
                        *((base + 20) as *mut i32) = result14 as i32;
                        cleanup_list.extend_from_slice(&[(result14, layout14),]);
                        
                      },
                      super::component::ComponentListTypeParam::TypeEntityId(e) => {
                        *((base + 16) as *mut u8) = (2i32) as u8;
                        let vec15 = e;
                        let ptr15 = vec15.as_ptr() as i32;
                        let len15 = vec15.len() as i32;
                        *((base + 24) as *mut i32) = len15;
                        *((base + 20) as *mut i32) = ptr15;
                        
                      },
                      super::component::ComponentListTypeParam::TypeF32(e) => {
                        *((base + 16) as *mut u8) = (3i32) as u8;
                        let vec16 = e;
                        let ptr16 = vec16.as_ptr() as i32;
                        let len16 = vec16.len() as i32;
                        *((base + 24) as *mut i32) = len16;
                        *((base + 20) as *mut i32) = ptr16;
                        
                      },
                      super::component::ComponentListTypeParam::TypeF64(e) => {
                        *((base + 16) as *mut u8) = (4i32) as u8;
                        let vec17 = e;
                        let ptr17 = vec17.as_ptr() as i32;
                        let len17 = vec17.len() as i32;
                        *((base + 24) as *mut i32) = len17;
                        *((base + 20) as *mut i32) = ptr17;
                        
                      },
                      super::component::ComponentListTypeParam::TypeMat4(e) => {
                        *((base + 16) as *mut u8) = (5i32) as u8;
                        let vec18 = e;
                        let ptr18 = vec18.as_ptr() as i32;
                        let len18 = vec18.len() as i32;
                        *((base + 24) as *mut i32) = len18;
                        *((base + 20) as *mut i32) = ptr18;
                        
                      },
                      super::component::ComponentListTypeParam::TypeI32(e) => {
                        *((base + 16) as *mut u8) = (6i32) as u8;
                        let vec19 = e;
                        let ptr19 = vec19.as_ptr() as i32;
                        let len19 = vec19.len() as i32;
                        *((base + 24) as *mut i32) = len19;
                        *((base + 20) as *mut i32) = ptr19;
                        
                      },
                      super::component::ComponentListTypeParam::TypeQuat(e) => {
                        *((base + 16) as *mut u8) = (7i32) as u8;
                        let vec20 = e;
                        let ptr20 = vec20.as_ptr() as i32;
                        let len20 = vec20.len() as i32;
                        *((base + 24) as *mut i32) = len20;
                        *((base + 20) as *mut i32) = ptr20;
                        
                      },
                      super::component::ComponentListTypeParam::TypeString(e) => {
                        *((base + 16) as *mut u8) = (8i32) as u8;
                        let vec22 = e;
                        let len22 = vec22.len() as i32;
                        let layout22 = alloc::Layout::from_size_align_unchecked(vec22.len() * 8, 4);
                        let result22 = if layout22.size() != 0
                        {
                          let ptr = alloc::alloc(layout22);
                          if ptr.is_null()
                          {
                            alloc::handle_alloc_error(layout22);
                          }
                          ptr
                        }else {
                          core::ptr::null_mut()
                        };
                        for (i, e) in vec22.into_iter().enumerate() {
                          let base = result22 as i32 + (i as i32) * 8;
                          {
                            let vec21 = e;
                            let ptr21 = vec21.as_ptr() as i32;
                            let len21 = vec21.len() as i32;
                            *((base + 4) as *mut i32) = len21;
                            *((base + 0) as *mut i32) = ptr21;
                            
                          }}
                          *((base + 24) as *mut i32) = len22;
                          *((base + 20) as *mut i32) = result22 as i32;
                          cleanup_list.extend_from_slice(&[(result22, layout22),]);
                          
                        },
                        super::component::ComponentListTypeParam::TypeU32(e) => {
                          *((base + 16) as *mut u8) = (9i32) as u8;
                          let vec23 = e;
                          let ptr23 = vec23.as_ptr() as i32;
                          let len23 = vec23.len() as i32;
                          *((base + 24) as *mut i32) = len23;
                          *((base + 20) as *mut i32) = ptr23;
                          
                        },
                        super::component::ComponentListTypeParam::TypeU64(e) => {
                          *((base + 16) as *mut u8) = (10i32) as u8;
                          let vec24 = e;
                          let ptr24 = vec24.as_ptr() as i32;
                          let len24 = vec24.len() as i32;
                          *((base + 24) as *mut i32) = len24;
                          *((base + 20) as *mut i32) = ptr24;
                          
                        },
                        super::component::ComponentListTypeParam::TypeVec2(e) => {
                          *((base + 16) as *mut u8) = (11i32) as u8;
                          let vec25 = e;
                          let ptr25 = vec25.as_ptr() as i32;
                          let len25 = vec25.len() as i32;
                          *((base + 24) as *mut i32) = len25;
                          *((base + 20) as *mut i32) = ptr25;
                          
                        },
                        super::component::ComponentListTypeParam::TypeVec3(e) => {
                          *((base + 16) as *mut u8) = (12i32) as u8;
                          let vec26 = e;
                          let ptr26 = vec26.as_ptr() as i32;
                          let len26 = vec26.len() as i32;
                          *((base + 24) as *mut i32) = len26;
                          *((base + 20) as *mut i32) = ptr26;
                          
                        },
                        super::component::ComponentListTypeParam::TypeVec4(e) => {
                          *((base + 16) as *mut u8) = (13i32) as u8;
                          let vec27 = e;
                          let ptr27 = vec27.as_ptr() as i32;
                          let len27 = vec27.len() as i32;
                          *((base + 24) as *mut i32) = len27;
                          *((base + 20) as *mut i32) = ptr27;
                          
                        },
                      };
                      
                    },
                    super::component::ComponentTypeParam::TypeOption(e) => {
                      *((base + 8) as *mut u8) = (15i32) as u8;
                      match e {
                        super::component::ComponentOptionTypeParam::TypeEmpty(e) => {
                          *((base + 16) as *mut u8) = (0i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let () = e;
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeBool(e) => {
                          *((base + 16) as *mut u8) = (1i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 25) as *mut u8) = (match e { true => 1, false => 0 }) as u8;
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeEntityId(e) => {
                          *((base + 16) as *mut u8) = (2i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::EntityId{ id0:id029, id1:id129, } = e;
                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(id029);
                              *((base + 40) as *mut i64) = wit_bindgen::rt::as_i64(id129);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeF32(e) => {
                          *((base + 16) as *mut u8) = (3i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeF64(e) => {
                          *((base + 16) as *mut u8) = (4i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 32) as *mut f64) = wit_bindgen::rt::as_f64(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeMat4(e) => {
                          *((base + 16) as *mut u8) = (5i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Mat4{ x:x30, y:y30, z:z30, w:w30, } = e;
                              let super::types::Vec4{ x:x31, y:y31, z:z31, w:w31, } = x30;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x31);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y31);
                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z31);
                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w31);
                              let super::types::Vec4{ x:x32, y:y32, z:z32, w:w32, } = y30;
                              *((base + 44) as *mut f32) = wit_bindgen::rt::as_f32(x32);
                              *((base + 48) as *mut f32) = wit_bindgen::rt::as_f32(y32);
                              *((base + 52) as *mut f32) = wit_bindgen::rt::as_f32(z32);
                              *((base + 56) as *mut f32) = wit_bindgen::rt::as_f32(w32);
                              let super::types::Vec4{ x:x33, y:y33, z:z33, w:w33, } = z30;
                              *((base + 60) as *mut f32) = wit_bindgen::rt::as_f32(x33);
                              *((base + 64) as *mut f32) = wit_bindgen::rt::as_f32(y33);
                              *((base + 68) as *mut f32) = wit_bindgen::rt::as_f32(z33);
                              *((base + 72) as *mut f32) = wit_bindgen::rt::as_f32(w33);
                              let super::types::Vec4{ x:x34, y:y34, z:z34, w:w34, } = w30;
                              *((base + 76) as *mut f32) = wit_bindgen::rt::as_f32(x34);
                              *((base + 80) as *mut f32) = wit_bindgen::rt::as_f32(y34);
                              *((base + 84) as *mut f32) = wit_bindgen::rt::as_f32(z34);
                              *((base + 88) as *mut f32) = wit_bindgen::rt::as_f32(w34);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeI32(e) => {
                          *((base + 16) as *mut u8) = (6i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeQuat(e) => {
                          *((base + 16) as *mut u8) = (7i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Quat{ x:x35, y:y35, z:z35, w:w35, } = e;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x35);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y35);
                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z35);
                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w35);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeString(e) => {
                          *((base + 16) as *mut u8) = (8i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let vec36 = e;
                              let ptr36 = vec36.as_ptr() as i32;
                              let len36 = vec36.len() as i32;
                              *((base + 32) as *mut i32) = len36;
                              *((base + 28) as *mut i32) = ptr36;
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeU32(e) => {
                          *((base + 16) as *mut u8) = (9i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 28) as *mut i32) = wit_bindgen::rt::as_i32(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeU64(e) => {
                          *((base + 16) as *mut u8) = (10i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              *((base + 32) as *mut i64) = wit_bindgen::rt::as_i64(e);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeVec2(e) => {
                          *((base + 16) as *mut u8) = (11i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Vec2{ x:x37, y:y37, } = e;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x37);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y37);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeVec3(e) => {
                          *((base + 16) as *mut u8) = (12i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Vec3{ x:x38, y:y38, z:z38, } = e;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x38);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y38);
                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z38);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                        super::component::ComponentOptionTypeParam::TypeVec4(e) => {
                          *((base + 16) as *mut u8) = (13i32) as u8;
                          match e {
                            Some(e) => {
                              *((base + 24) as *mut u8) = (1i32) as u8;
                              let super::types::Vec4{ x:x39, y:y39, z:z39, w:w39, } = e;
                              *((base + 28) as *mut f32) = wit_bindgen::rt::as_f32(x39);
                              *((base + 32) as *mut f32) = wit_bindgen::rt::as_f32(y39);
                              *((base + 36) as *mut f32) = wit_bindgen::rt::as_f32(z39);
                              *((base + 40) as *mut f32) = wit_bindgen::rt::as_f32(w39);
                              
                            },
                            None => {
                              {
                                *((base + 24) as *mut u8) = (0i32) as u8;
                                
                              }
                            },
                          };
                        },
                      };
                      
                    },
                  };
                  
                }}
                let ptr41 = ret_area.as_mut_ptr() as i32;
                #[link(wasm_import_module = "entity")]
                extern "C" {
                  #[cfg_attr(target_arch = "wasm32", link_name = "spawn")]
                  #[cfg_attr(not(target_arch = "wasm32"), link_name = "entity_spawn")]
                  fn wit_import(
                  _: i32, _: i32, _: i32, );
                }
                wit_import(result40 as i32, len40, ptr41);
                if layout40.size() != 0 {
                  alloc::dealloc(result40, layout40);
                }
                for (ptr, layout) in cleanup_list {
                  
                  if layout.size() != 0 {
                    
                    alloc::dealloc(ptr, layout);
                    
                  }
                  
                }
                super::types::EntityId{id0:*((ptr41 + 0) as *const i64) as u64, id1:*((ptr41 + 8) as *const i64) as u64, }
              }
            }
            
          }
          
          
          #[allow(clippy::all)]
          pub mod guest{ use super::wit_bindgen;
            pub type ComponentType = super::component::ComponentTypeResult;
            pub trait Guest {
              fn init();
              fn exec(event_data: wit_bindgen::rt::vec::Vec::<(u32,ComponentType,)>,);
            }
            
            #[doc(hidden)]
            pub unsafe fn call_init<T: Guest>() {
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              T::init();
            }
            
            #[doc(hidden)]
            pub unsafe fn call_exec<T: Guest>(arg0: i32,arg1: i32,) {
              
              #[allow(unused_imports)]
              use wit_bindgen::rt::{alloc, vec::Vec, string::String};
              let base17 = arg0;
              let len17 = arg1;
              let mut result17 = Vec::with_capacity(len17 as usize);
              for i in 0..len17 {
                let base = base17 + i *88;
                result17.push((*((base + 0) as *const i32) as u32, {{match i32::from(*((base + 8) as *const u8)) {
                  0 => super::component::ComponentTypeResult::TypeEmpty(()),
                  1 => super::component::ComponentTypeResult::TypeBool({
                    #[cfg(not(debug_assertions))]
                    { core::mem::transmute::<u8, bool>(i32::from(*((base + 16) as *const u8)) as u8) }
                    #[cfg(debug_assertions)]
                    {
                      match i32::from(*((base + 16) as *const u8)) {
                        0 => false,
                        1 => true,
                        _ => panic!("invalid bool discriminant"),
                      }
                    }
                  }),
                  2 => super::component::ComponentTypeResult::TypeEntityId(super::types::EntityId{id0:*((base + 16) as *const i64) as u64, id1:*((base + 24) as *const i64) as u64, }),
                  3 => super::component::ComponentTypeResult::TypeF32(*((base + 16) as *const f32)),
                  4 => super::component::ComponentTypeResult::TypeF64(*((base + 16) as *const f64)),
                  5 => super::component::ComponentTypeResult::TypeMat4(super::types::Mat4{x:super::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }, y:super::types::Vec4{x:*((base + 32) as *const f32), y:*((base + 36) as *const f32), z:*((base + 40) as *const f32), w:*((base + 44) as *const f32), }, z:super::types::Vec4{x:*((base + 48) as *const f32), y:*((base + 52) as *const f32), z:*((base + 56) as *const f32), w:*((base + 60) as *const f32), }, w:super::types::Vec4{x:*((base + 64) as *const f32), y:*((base + 68) as *const f32), z:*((base + 72) as *const f32), w:*((base + 76) as *const f32), }, }),
                  6 => super::component::ComponentTypeResult::TypeI32(*((base + 16) as *const i32)),
                  7 => super::component::ComponentTypeResult::TypeQuat(super::types::Quat{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                  8 => super::component::ComponentTypeResult::TypeString({
                    let len0 = *((base + 20) as *const i32) as usize;
                    
                    {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len0, len0))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 16) as *const i32) as *mut _, len0, len0)).unwrap()}}
                  }),
                  9 => super::component::ComponentTypeResult::TypeU32(*((base + 16) as *const i32) as u32),
                  10 => super::component::ComponentTypeResult::TypeU64(*((base + 16) as *const i64) as u64),
                  11 => super::component::ComponentTypeResult::TypeVec2(super::types::Vec2{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), }),
                  12 => super::component::ComponentTypeResult::TypeVec3(super::types::Vec3{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), }),
                  13 => super::component::ComponentTypeResult::TypeVec4(super::types::Vec4{x:*((base + 16) as *const f32), y:*((base + 20) as *const f32), z:*((base + 24) as *const f32), w:*((base + 28) as *const f32), }),
                  14 => super::component::ComponentTypeResult::TypeList({{match i32::from(*((base + 16) as *const u8)) {
                    0 => super::component::ComponentListTypeResult::TypeEmpty({
                      let len1 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len1, len1)
                    }),
                    1 => super::component::ComponentListTypeResult::TypeBool({
                      let base2 = *((base + 20) as *const i32);
                      let len2 = *((base + 24) as *const i32);
                      let mut result2 = Vec::with_capacity(len2 as usize);
                      for i in 0..len2 {
                        let base = base2 + i *1;
                        result2.push({
                          #[cfg(not(debug_assertions))]
                          { core::mem::transmute::<u8, bool>(i32::from(*((base + 0) as *const u8)) as u8) }
                          #[cfg(debug_assertions)]
                          {
                            match i32::from(*((base + 0) as *const u8)) {
                              0 => false,
                              1 => true,
                              _ => panic!("invalid bool discriminant"),
                            }
                          }
                        });
                      }
                      wit_bindgen::rt::dealloc(base2, (len2 as usize) * 1, 1);
                      
                      result2
                    }),
                    2 => super::component::ComponentListTypeResult::TypeEntityId({
                      let len3 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len3, len3)
                    }),
                    3 => super::component::ComponentListTypeResult::TypeF32({
                      let len4 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len4, len4)
                    }),
                    4 => super::component::ComponentListTypeResult::TypeF64({
                      let len5 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len5, len5)
                    }),
                    5 => super::component::ComponentListTypeResult::TypeMat4({
                      let len6 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len6, len6)
                    }),
                    6 => super::component::ComponentListTypeResult::TypeI32({
                      let len7 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len7, len7)
                    }),
                    7 => super::component::ComponentListTypeResult::TypeQuat({
                      let len8 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len8, len8)
                    }),
                    8 => super::component::ComponentListTypeResult::TypeString({
                      let base10 = *((base + 20) as *const i32);
                      let len10 = *((base + 24) as *const i32);
                      let mut result10 = Vec::with_capacity(len10 as usize);
                      for i in 0..len10 {
                        let base = base10 + i *8;
                        result10.push({
                          let len9 = *((base + 4) as *const i32) as usize;
                          
                          {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len9, len9))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 0) as *const i32) as *mut _, len9, len9)).unwrap()}}
                        });
                      }
                      wit_bindgen::rt::dealloc(base10, (len10 as usize) * 8, 4);
                      
                      result10
                    }),
                    9 => super::component::ComponentListTypeResult::TypeU32({
                      let len11 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len11, len11)
                    }),
                    10 => super::component::ComponentListTypeResult::TypeU64({
                      let len12 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len12, len12)
                    }),
                    11 => super::component::ComponentListTypeResult::TypeVec2({
                      let len13 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len13, len13)
                    }),
                    12 => super::component::ComponentListTypeResult::TypeVec3({
                      let len14 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len14, len14)
                    }),
                    #[cfg(debug_assertions)]13 => super::component::ComponentListTypeResult::TypeVec4({
                      let len15 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len15, len15)
                    }),
                    #[cfg(not(debug_assertions))]_ => super::component::ComponentListTypeResult::TypeVec4({
                      let len15 = *((base + 24) as *const i32) as usize;
                      
                      Vec::from_raw_parts(*((base + 20) as *const i32) as *mut _, len15, len15)
                    }),
                    #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                  }}}),
                  #[cfg(debug_assertions)]15 => super::component::ComponentTypeResult::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                    0 => super::component::ComponentOptionTypeResult::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(()),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    1 => super::component::ComponentOptionTypeResult::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some({
                        #[cfg(not(debug_assertions))]
                        { core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                        #[cfg(debug_assertions)]
                        {
                          match i32::from(*((base + 25) as *const u8)) {
                            0 => false,
                            1 => true,
                            _ => panic!("invalid bool discriminant"),
                          }
                        }
                      }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    2 => super::component::ComponentOptionTypeResult::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    3 => super::component::ComponentOptionTypeResult::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 28) as *const f32)),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    4 => super::component::ComponentOptionTypeResult::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 32) as *const f64)),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    5 => super::component::ComponentOptionTypeResult::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    6 => super::component::ComponentOptionTypeResult::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 28) as *const i32)),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    7 => super::component::ComponentOptionTypeResult::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    8 => super::component::ComponentOptionTypeResult::TypeString(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some({
                        let len16 = *((base + 32) as *const i32) as usize;
                        
                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len16, len16))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len16, len16)).unwrap()}}
                      }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    9 => super::component::ComponentOptionTypeResult::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 28) as *const i32) as u32),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    10 => super::component::ComponentOptionTypeResult::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 32) as *const i64) as u64),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    11 => super::component::ComponentOptionTypeResult::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    12 => super::component::ComponentOptionTypeResult::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    #[cfg(debug_assertions)]13 => super::component::ComponentOptionTypeResult::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    #[cfg(not(debug_assertions))]_ => super::component::ComponentOptionTypeResult::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                  }}}),
                  #[cfg(not(debug_assertions))]_ => super::component::ComponentTypeResult::TypeOption({{match i32::from(*((base + 16) as *const u8)) {
                    0 => super::component::ComponentOptionTypeResult::TypeEmpty(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(()),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    1 => super::component::ComponentOptionTypeResult::TypeBool(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some({
                        #[cfg(not(debug_assertions))]
                        { core::mem::transmute::<u8, bool>(i32::from(*((base + 25) as *const u8)) as u8) }
                        #[cfg(debug_assertions)]
                        {
                          match i32::from(*((base + 25) as *const u8)) {
                            0 => false,
                            1 => true,
                            _ => panic!("invalid bool discriminant"),
                          }
                        }
                      }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    2 => super::component::ComponentOptionTypeResult::TypeEntityId(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::EntityId{id0:*((base + 32) as *const i64) as u64, id1:*((base + 40) as *const i64) as u64, }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    3 => super::component::ComponentOptionTypeResult::TypeF32(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 28) as *const f32)),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    4 => super::component::ComponentOptionTypeResult::TypeF64(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 32) as *const f64)),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    5 => super::component::ComponentOptionTypeResult::TypeMat4(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Mat4{x:super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }, y:super::types::Vec4{x:*((base + 44) as *const f32), y:*((base + 48) as *const f32), z:*((base + 52) as *const f32), w:*((base + 56) as *const f32), }, z:super::types::Vec4{x:*((base + 60) as *const f32), y:*((base + 64) as *const f32), z:*((base + 68) as *const f32), w:*((base + 72) as *const f32), }, w:super::types::Vec4{x:*((base + 76) as *const f32), y:*((base + 80) as *const f32), z:*((base + 84) as *const f32), w:*((base + 88) as *const f32), }, }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    6 => super::component::ComponentOptionTypeResult::TypeI32(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 28) as *const i32)),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    7 => super::component::ComponentOptionTypeResult::TypeQuat(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Quat{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    8 => super::component::ComponentOptionTypeResult::TypeString(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some({
                        let len16 = *((base + 32) as *const i32) as usize;
                        
                        {#[cfg(not(debug_assertions))]{String::from_utf8_unchecked(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len16, len16))}#[cfg(debug_assertions)]{String::from_utf8(Vec::from_raw_parts(*((base + 28) as *const i32) as *mut _, len16, len16)).unwrap()}}
                      }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    9 => super::component::ComponentOptionTypeResult::TypeU32(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 28) as *const i32) as u32),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    10 => super::component::ComponentOptionTypeResult::TypeU64(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(*((base + 32) as *const i64) as u64),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    11 => super::component::ComponentOptionTypeResult::TypeVec2(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Vec2{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    12 => super::component::ComponentOptionTypeResult::TypeVec3(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Vec3{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    #[cfg(debug_assertions)]13 => super::component::ComponentOptionTypeResult::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    #[cfg(not(debug_assertions))]_ => super::component::ComponentOptionTypeResult::TypeVec4(match i32::from(*((base + 24) as *const u8)) {
                      0 => None,
                      1 => Some(super::types::Vec4{x:*((base + 28) as *const f32), y:*((base + 32) as *const f32), z:*((base + 36) as *const f32), w:*((base + 40) as *const f32), }),
                      #[cfg(not(debug_assertions))]
                      _ => core::hint::unreachable_unchecked(),
                      #[cfg(debug_assertions)]
                      _ => panic!("invalid enum discriminant"),
                    }),
                    #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                  }}}),
                  #[cfg(debug_assertions)]_ => panic!("invalid enum discriminant"),
                }}}));
              }
              wit_bindgen::rt::dealloc(base17, (len17 as usize) * 88, 8);
              T::exec(result17);
            }
            
          }
          
          
          /// Declares the export of the component's world for the
          /// given type.
          
          macro_rules! export_server(($t:ident) => {
            const _: () = {
              
              #[doc(hidden)]
              #[export_name = "guest#init"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_guest_init() {
                guest::call_init::<$t>()
              }
              
              #[doc(hidden)]
              #[export_name = "guest#exec"]
              #[allow(non_snake_case)]
              unsafe extern "C" fn __export_guest_exec(arg0: i32,arg1: i32,) {
                guest::call_exec::<$t>(arg0,arg1,)
              }
              
            };
            
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() = __force_section_ref;
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            fn __force_section_ref() {
              __link_section()
            }
          });
          
          #[cfg(target_arch = "wasm32")]
          #[link_section = "component-type:server"]
          #[doc(hidden)]pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 5634] = [2, 0, 3, 119, 105, 116, 4, 109, 97, 105, 110, 6, 115, 101, 114, 118, 101, 114, 0, 97, 115, 109, 12, 0, 1, 0, 7, 176, 1, 1, 65, 2, 1, 66, 12, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 6, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 8, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 10, 4, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 11, 21, 1, 5, 116, 121, 112, 101, 115, 10, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 3, 0, 0, 7, 204, 9, 1, 65, 10, 1, 66, 12, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 6, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 8, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 10, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 52, 1, 66, 55, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 6, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 1, 111, 0, 1, 107, 12, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 113, 14, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 13, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 14, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 15, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 16, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 17, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 18, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 19, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 20, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 21, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 22, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 23, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 24, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 25, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 26, 0, 4, 21, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 111, 112, 116, 105, 111, 110, 45, 116, 121, 112, 101, 0, 3, 0, 27, 1, 112, 12, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 121, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 113, 14, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 29, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 30, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 31, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 32, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 33, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 34, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 35, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 36, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 37, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 38, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 39, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 40, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 41, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 42, 0, 4, 19, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 108, 105, 115, 116, 45, 116, 121, 112, 101, 0, 3, 0, 43, 1, 113, 16, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 12, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 9, 116, 121, 112, 101, 45, 108, 105, 115, 116, 1, 44, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 28, 0, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 45, 1, 111, 2, 121, 46, 1, 112, 47, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 48, 1, 107, 46, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 50, 4, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 51, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 46, 1, 0, 4, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 52, 4, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 7, 11, 29, 1, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 14, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 3, 2, 0, 7, 239, 9, 1, 65, 13, 1, 66, 12, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 6, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 8, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 10, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 52, 1, 66, 50, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 6, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 1, 111, 0, 1, 107, 12, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 113, 14, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 13, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 14, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 15, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 16, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 17, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 18, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 19, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 20, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 21, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 22, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 23, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 24, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 25, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 26, 0, 4, 21, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 111, 112, 116, 105, 111, 110, 45, 116, 121, 112, 101, 0, 3, 0, 27, 1, 112, 12, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 121, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 113, 14, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 29, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 30, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 31, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 32, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 33, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 34, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 35, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 36, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 37, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 38, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 39, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 40, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 41, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 42, 0, 4, 19, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 108, 105, 115, 116, 45, 116, 121, 112, 101, 0, 3, 0, 43, 1, 113, 16, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 12, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 9, 116, 121, 112, 101, 45, 108, 105, 115, 116, 1, 44, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 28, 0, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 45, 1, 111, 2, 121, 46, 1, 112, 47, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 48, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 7, 2, 3, 0, 1, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 1, 66, 8, 2, 3, 2, 1, 8, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 0, 1, 64, 0, 1, 0, 4, 4, 105, 110, 105, 116, 0, 1, 2, 1, 111, 2, 121, 1, 1, 112, 3, 1, 64, 1, 10, 101, 118, 101, 110, 116, 45, 100, 97, 116, 97, 4, 1, 0, 4, 4, 101, 120, 101, 99, 0, 1, 5, 4, 5, 103, 117, 101, 115, 116, 16, 112, 107, 103, 58, 47, 103, 117, 101, 115, 116, 47, 103, 117, 101, 115, 116, 5, 9, 11, 21, 1, 5, 103, 117, 101, 115, 116, 10, 112, 107, 103, 58, 47, 103, 117, 101, 115, 116, 3, 4, 0, 7, 224, 9, 1, 65, 13, 1, 66, 12, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 6, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 8, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 10, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 52, 1, 66, 50, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 6, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 1, 111, 0, 1, 107, 12, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 113, 14, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 13, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 14, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 15, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 16, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 17, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 18, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 19, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 20, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 21, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 22, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 23, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 24, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 25, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 26, 0, 4, 21, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 111, 112, 116, 105, 111, 110, 45, 116, 121, 112, 101, 0, 3, 0, 27, 1, 112, 12, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 121, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 113, 14, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 29, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 30, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 31, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 32, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 33, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 34, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 35, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 36, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 37, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 38, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 39, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 40, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 41, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 42, 0, 4, 19, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 108, 105, 115, 116, 45, 116, 121, 112, 101, 0, 3, 0, 43, 1, 113, 16, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 12, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 9, 116, 121, 112, 101, 45, 108, 105, 115, 116, 1, 44, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 28, 0, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 45, 1, 111, 2, 121, 46, 1, 112, 47, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 48, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 7, 2, 3, 0, 1, 6, 101, 110, 116, 105, 116, 121, 1, 66, 6, 2, 3, 2, 1, 8, 4, 11, 101, 110, 116, 105, 116, 121, 45, 100, 97, 116, 97, 0, 3, 0, 0, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 2, 1, 64, 1, 4, 100, 97, 116, 97, 1, 0, 3, 4, 5, 115, 112, 97, 119, 110, 0, 1, 4, 4, 6, 101, 110, 116, 105, 116, 121, 18, 112, 107, 103, 58, 47, 101, 110, 116, 105, 116, 121, 47, 101, 110, 116, 105, 116, 121, 5, 9, 11, 23, 1, 6, 101, 110, 116, 105, 116, 121, 11, 112, 107, 103, 58, 47, 101, 110, 116, 105, 116, 121, 3, 6, 0, 7, 205, 11, 1, 65, 2, 1, 65, 16, 1, 66, 12, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 118, 101, 99, 52, 0, 3, 0, 0, 1, 114, 3, 1, 120, 118, 1, 121, 118, 1, 122, 118, 4, 4, 118, 101, 99, 51, 0, 3, 0, 2, 1, 114, 2, 1, 120, 118, 1, 121, 118, 4, 4, 118, 101, 99, 50, 0, 3, 0, 4, 1, 114, 4, 1, 120, 118, 1, 121, 118, 1, 122, 118, 1, 119, 118, 4, 4, 113, 117, 97, 116, 0, 3, 0, 6, 1, 114, 4, 1, 120, 1, 1, 121, 1, 1, 122, 1, 1, 119, 1, 4, 4, 109, 97, 116, 52, 0, 3, 0, 8, 1, 114, 2, 3, 105, 100, 48, 119, 3, 105, 100, 49, 119, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 10, 3, 5, 116, 121, 112, 101, 115, 16, 112, 107, 103, 58, 47, 116, 121, 112, 101, 115, 47, 116, 121, 112, 101, 115, 5, 0, 2, 3, 0, 0, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 2, 3, 0, 0, 4, 109, 97, 116, 52, 2, 3, 0, 0, 4, 113, 117, 97, 116, 2, 3, 0, 0, 4, 118, 101, 99, 50, 2, 3, 0, 0, 4, 118, 101, 99, 51, 2, 3, 0, 0, 4, 118, 101, 99, 52, 1, 66, 55, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 0, 2, 3, 2, 1, 2, 4, 4, 109, 97, 116, 52, 0, 3, 0, 2, 2, 3, 2, 1, 3, 4, 4, 113, 117, 97, 116, 0, 3, 0, 4, 2, 3, 2, 1, 4, 4, 4, 118, 101, 99, 50, 0, 3, 0, 6, 2, 3, 2, 1, 5, 4, 4, 118, 101, 99, 51, 0, 3, 0, 8, 2, 3, 2, 1, 6, 4, 4, 118, 101, 99, 52, 0, 3, 0, 10, 1, 111, 0, 1, 107, 12, 1, 107, 127, 1, 107, 1, 1, 107, 118, 1, 107, 117, 1, 107, 3, 1, 107, 122, 1, 107, 5, 1, 107, 115, 1, 107, 121, 1, 107, 119, 1, 107, 7, 1, 107, 9, 1, 107, 11, 1, 113, 14, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 13, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 14, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 15, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 16, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 17, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 18, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 19, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 20, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 21, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 22, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 23, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 24, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 25, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 26, 0, 4, 21, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 111, 112, 116, 105, 111, 110, 45, 116, 121, 112, 101, 0, 3, 0, 27, 1, 112, 12, 1, 112, 127, 1, 112, 1, 1, 112, 118, 1, 112, 117, 1, 112, 3, 1, 112, 122, 1, 112, 5, 1, 112, 115, 1, 112, 121, 1, 112, 119, 1, 112, 7, 1, 112, 9, 1, 112, 11, 1, 113, 14, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 29, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 30, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 31, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 32, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 33, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 34, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 35, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 36, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 37, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 38, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 39, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 40, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 41, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 42, 0, 4, 19, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 108, 105, 115, 116, 45, 116, 121, 112, 101, 0, 3, 0, 43, 1, 113, 16, 10, 116, 121, 112, 101, 45, 101, 109, 112, 116, 121, 1, 12, 0, 9, 116, 121, 112, 101, 45, 98, 111, 111, 108, 1, 127, 0, 14, 116, 121, 112, 101, 45, 101, 110, 116, 105, 116, 121, 45, 105, 100, 1, 1, 0, 8, 116, 121, 112, 101, 45, 102, 51, 50, 1, 118, 0, 8, 116, 121, 112, 101, 45, 102, 54, 52, 1, 117, 0, 9, 116, 121, 112, 101, 45, 109, 97, 116, 52, 1, 3, 0, 8, 116, 121, 112, 101, 45, 105, 51, 50, 1, 122, 0, 9, 116, 121, 112, 101, 45, 113, 117, 97, 116, 1, 5, 0, 11, 116, 121, 112, 101, 45, 115, 116, 114, 105, 110, 103, 1, 115, 0, 8, 116, 121, 112, 101, 45, 117, 51, 50, 1, 121, 0, 8, 116, 121, 112, 101, 45, 117, 54, 52, 1, 119, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 50, 1, 7, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 51, 1, 9, 0, 9, 116, 121, 112, 101, 45, 118, 101, 99, 52, 1, 11, 0, 9, 116, 121, 112, 101, 45, 108, 105, 115, 116, 1, 44, 0, 11, 116, 121, 112, 101, 45, 111, 112, 116, 105, 111, 110, 1, 28, 0, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 45, 1, 111, 2, 121, 46, 1, 112, 47, 4, 6, 101, 110, 116, 105, 116, 121, 0, 3, 0, 48, 1, 107, 46, 1, 64, 2, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 0, 50, 4, 13, 103, 101, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 51, 1, 64, 3, 6, 101, 110, 116, 105, 116, 121, 1, 5, 105, 110, 100, 101, 120, 121, 5, 118, 97, 108, 117, 101, 46, 1, 0, 4, 13, 97, 100, 100, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 0, 1, 52, 3, 9, 99, 111, 109, 112, 111, 110, 101, 110, 116, 24, 112, 107, 103, 58, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 47, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 7, 2, 3, 0, 1, 6, 101, 110, 116, 105, 116, 121, 1, 66, 6, 2, 3, 2, 1, 8, 4, 11, 101, 110, 116, 105, 116, 121, 45, 100, 97, 116, 97, 0, 3, 0, 0, 2, 3, 2, 1, 1, 4, 9, 101, 110, 116, 105, 116, 121, 45, 105, 100, 0, 3, 0, 2, 1, 64, 1, 4, 100, 97, 116, 97, 1, 0, 3, 4, 5, 115, 112, 97, 119, 110, 0, 1, 4, 3, 6, 101, 110, 116, 105, 116, 121, 18, 112, 107, 103, 58, 47, 101, 110, 116, 105, 116, 121, 47, 101, 110, 116, 105, 116, 121, 5, 9, 2, 3, 0, 1, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 1, 66, 8, 2, 3, 2, 1, 10, 4, 14, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 116, 121, 112, 101, 0, 3, 0, 0, 1, 64, 0, 1, 0, 4, 4, 105, 110, 105, 116, 0, 1, 2, 1, 111, 2, 121, 1, 1, 112, 3, 1, 64, 1, 10, 101, 118, 101, 110, 116, 45, 100, 97, 116, 97, 4, 1, 0, 4, 4, 101, 120, 101, 99, 0, 1, 5, 4, 5, 103, 117, 101, 115, 116, 16, 112, 107, 103, 58, 47, 103, 117, 101, 115, 116, 47, 103, 117, 101, 115, 116, 5, 11, 4, 6, 115, 101, 114, 118, 101, 114, 16, 112, 107, 103, 58, 47, 109, 97, 105, 110, 47, 115, 101, 114, 118, 101, 114, 4, 0, 0, 68, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 5, 48, 46, 55, 46, 49, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 5, 48, 46, 51, 46, 48, 11, 19, 1, 4, 109, 97, 105, 110, 9, 112, 107, 103, 58, 47, 109, 97, 105, 110, 3, 8, 0];
          
          #[inline(never)]
          #[doc(hidden)]
          #[cfg(target_arch = "wasm32")]
          pub fn __link_section() {}
          